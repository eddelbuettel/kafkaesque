% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kafka_class_consumer.R
\name{kafka_class_consumer}
\alias{kafka_class_consumer}
\title{R6 Class for Kafka Consumer}
\description{
R6 Class for Kafka Consumer

R6 Class for Kafka Consumer
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{java_consumer}}{reference to the underlying Java object}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{kafka_class_consumer$new()}}
\item \href{#method-finalize}{\code{kafka_class_consumer$finalize()}}
\item \href{#method-start}{\code{kafka_class_consumer$start()}}
\item \href{#method-end}{\code{kafka_class_consumer$end()}}
\item \href{#method-poll}{\code{kafka_class_consumer$poll()}}
\item \href{#method-offset}{\code{kafka_class_consumer$offset()}}
\item \href{#method-consume_next}{\code{kafka_class_consumer$consume_next()}}
\item \href{#method-consume_loop}{\code{kafka_class_consumer$consume_loop()}}
\item \href{#method-props}{\code{kafka_class_consumer$props()}}
\item \href{#method-topics_subscribe}{\code{kafka_class_consumer$topics_subscribe()}}
\item \href{#method-topics_subscription}{\code{kafka_class_consumer$topics_subscription()}}
\item \href{#method-topics_list}{\code{kafka_class_consumer$topics_list()}}
\item \href{#method-clone}{\code{kafka_class_consumer$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new consumer object.
Instead of \code{kafka_class_consumer$new()} one can use \code{kafka_consumer()}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_class_consumer$new()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
returns object reference for method chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-finalize"></a>}}
\if{latex}{\out{\hypertarget{method-finalize}{}}}
\subsection{Method \code{finalize()}}{
Code run when object is removed from session
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_class_consumer$finalize()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-start"></a>}}
\if{latex}{\out{\hypertarget{method-start}{}}}
\subsection{Method \code{start()}}{
Spin up consumer and connect it to Kafka cluster
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_class_consumer$start()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
returns object reference for method chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-end"></a>}}
\if{latex}{\out{\hypertarget{method-end}{}}}
\subsection{Method \code{end()}}{
Disconnect consumer from Kafka cluster
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_class_consumer$end()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
returns object reference for method chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-poll"></a>}}
\if{latex}{\out{\hypertarget{method-poll}{}}}
\subsection{Method \code{poll()}}{
Polling for messages
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_class_consumer$poll(timeout_ms = NULL)}\if{html}{\out{</div>}}
}

\subsection{Returns}{
returns object reference for method chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-offset"></a>}}
\if{latex}{\out{\hypertarget{method-offset}{}}}
\subsection{Method \code{offset()}}{
If poll() did fetch any messages, they are stored here until the
next call to poll().

Note: Consider using consume methods instead of managing records on your own.


Set/return offsets.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_class_consumer$offset(offset = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{offset}}{defaults to NULL, if set to NULL now new offset will
be set, if set to a number this number will be used as new offset}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-consume_next"></a>}}
\if{latex}{\out{\hypertarget{method-consume_next}{}}}
\subsection{Method \code{consume_next()}}{
Consume one message either from the records already fetched from last poll or via initiating a new poll.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_class_consumer$consume_next()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-consume_loop"></a>}}
\if{latex}{\out{\hypertarget{method-consume_loop}{}}}
\subsection{Method \code{consume_loop()}}{
If poll() did fetch any messages, they are stored here until the next
call to poll()
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_class_consumer$consume_loop(
  expr = expression(print(msgs)),
  check = expression(counter < 1),
  batch = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{expr}}{expression (e.g. via \code{expression(...)}) that will
process a single message}

\item{\code{check}}{expression (e.g. via \code{expression(...)}) that will
evaluate to TRUE or FALSE to either further process messages or
stop processing and ask function to return}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-props"></a>}}
\if{latex}{\out{\hypertarget{method-props}{}}}
\subsection{Method \code{props()}}{
Polling for messages
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_class_consumer$props()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-topics_subscribe"></a>}}
\if{latex}{\out{\hypertarget{method-topics_subscribe}{}}}
\subsection{Method \code{topics_subscribe()}}{
Subscribe to one or more topics
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_class_consumer$topics_subscribe(topics)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{topics}}{character vector defining topics or topic regex to subscribe to}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
returns object reference for method chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-topics_subscription"></a>}}
\if{latex}{\out{\hypertarget{method-topics_subscription}{}}}
\subsection{Method \code{topics_subscription()}}{
List current subscription
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_class_consumer$topics_subscription()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-topics_list"></a>}}
\if{latex}{\out{\hypertarget{method-topics_list}{}}}
\subsection{Method \code{topics_list()}}{
List topics available to consumer
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_class_consumer$topics_list(full = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_class_consumer$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
