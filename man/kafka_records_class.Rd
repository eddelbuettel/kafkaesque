% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kafka_records.R
\name{kafka_records_class}
\alias{kafka_records_class}
\title{R6 Class for Kafka Records}
\description{
R6 Class for Kafka Records

R6 Class for Kafka Records
}
\details{
This class will handle kafka records.
It allows to manage polling for new messages, retrieval of messages from JVM,
local storage of message batches and iteration and forwarding messages or
message batches for consumption.

It abstracts storage, polling, forwarding into an iteratable interface where
messages can be accessed via \code{next_record()} and \code{next_record_batch()}.

The main problem here is that message consumption is not trivial for a couple
of reasons: (1) The R interface has to be in sync with the Java side of things
- there is an records object at the Java side.
(2) Kafka does fetch messages in batches. While batches might be as small as
0 or 1 message the default is to consume messages in batches of 500. This
makes consuming single messages a non trivial process since the batch size
is determined by how the consumer options were set e.g. timeouts and max
fetch sizes the number of available messages on the topic - all things
outside the s specific call of the poll method which executes data retrieval.
(3) Extra processing has to be done to translate records from Java into R.
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{kafka_records_class$new()}}
\item \href{#method-records_df}{\code{kafka_records_class$records_df()}}
\item \href{#method-next_record}{\code{kafka_records_class$next_record()}}
\item \href{#method-next_record_batch}{\code{kafka_records_class$next_record_batch()}}
\item \href{#method-clone}{\code{kafka_records_class$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new instance of class
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_records_class$new(parent)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{parent}}{enclosing consumer object}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-records_df"></a>}}
\if{latex}{\out{\hypertarget{method-records_df}{}}}
\subsection{Method \code{records_df()}}{

\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_records_class$records_df()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-next_record"></a>}}
\if{latex}{\out{\hypertarget{method-next_record}{}}}
\subsection{Method \code{next_record()}}{

\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_records_class$next_record()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-next_record_batch"></a>}}
\if{latex}{\out{\hypertarget{method-next_record_batch}{}}}
\subsection{Method \code{next_record_batch()}}{
Reference to consumer object that serves as parent.

Holds a batch of messages received from kafka consumer as data.frame
or data.table.

Records which message from local storage records is to be consumed next

Use poll method on kafka consumer to get new messages.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_records_class$next_record_batch()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{kafka_records_class$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
